# 1. Какие стандартные типы данных вы использовали в python?
# "Логический, может принимать одно из двух значений — True (истина) или False (ложь).
# Числа, могут быть целыми (1 и 2), с плавающей точкой (1.1 и 1.2), дробными (1/2 и 2/3), и даже комплексными.
# Строки — последовательности символов Юникода, например, HTML-документ.
# Байты и массивы байтов, например, файл изображения в формате JPEG.
# Списки — упорядоченные последовательности значений.
# Кортежи — упорядоченные неизменяемые последовательности значений.
# Множества — неупорядоченные наборы значений.
# Словари — неупорядоченные наборы пар вида ключ-значение."

# -------------------------------------------------
# 2. Сырые строки. ЧТо это?
# r'отключаем экранирование'

# -------------------------------------------------
# 3. В чем разница между tuple and list?
# кортежи неизменяемы, а списки - да. Это основная разница. Кортежы быстрее чем списки и стоит их использовать там,
# где есть набор элементов не требующий изменения.

# -------------------------------------------------
# 4. ЧТо такое set?
# Множество — это «мешок», содержащий неупорядоченные уникальные значения. Одно множество может содержать значения
# любых типов. Если у вас есть два множества, вы можете совершать над ними любые стандартные операции, например,
# объединение, пересечение и разность.

# 5. Стандартные библиотеки питона (sys, dtae, regex)
# Модули: os.path. Модуль json позволяет кодировать и декодировать данные в удобном формате. Модуль datetime
# предоставляет классы для обработки времени и даты разными способами. Модуль os предоставляет множество функций
# для работы с операционной системой, причём их поведение, как правило, не зависит от ОС, поэтому программы остаются
# переносимыми. Модуль unittest предоставляет богатый набор инструментов для написания и запуска тестов.

# -------------------------------------------------
# 6. Что такое pep8?
# Свод правил созданных на основе рекомендаций Гуидо ван Россума от том как лучше следуюет писать код чтобы максимально
# сделать его понятным для других программистов. Исходя из практики, код намного чаще читается чем пишется, поэтому так
# важно писать все в едином стиле, pep8 - диктует этот стиль для всех однозначно.

# -------------------------------------------------
# 7. Сделать swap 2-х переменных
a = 1
b = 3
a, b = b, a

# -------------------------------------------------
# 8. range и xrange в чем разница?
# Эта разница существует в версии питона 2. В третьей xrange не существует, а range стал себя вести как xrange.

# -------------------------------------------------
# 9. min or max value in list (задачка)
my_list = [1, 5, 7, 0]
print(max(my_list))

# -------------------------------------------------
# 10. удалить повторяющиеся элементы в листе
lis = [1, 1, 3, 4, 5, 5]
list(set(lis))

# -------------------------------------------------
# 11. строка - разрезать по разделителю
string = "0010000000100100000101010"
new_list = string.split('1')
print(new_list)

# -------------------------------------------------
# 12. mutable and immutable types
# "MUTABILITY OF COMMON TYPES
# The following are some immutable objects:

# int
# float
# decimal
# complex
# bool
# string
# tuple
# range
# frozenset
# bytes

# The following are some mutable objects:

# list
# dict
# set
# bytearray
# user-defined classes (unless specifically made immutable)

# -------------------------------------------------
# 13. итераторы и генераторы, yield.  Как его создать? Чем отличается iterator от iterable?
#  Итератор — это объект, который осуществляет доступ к элементам последовательности. Итерация — процесс (цикл)
# обработки элементов последовательности. Один шаг в цикле (тоже) называется итерацией. На каждой итерации итератор
# ( с помощью своего метода __next__)  указывает на следующий и возвращает текущий элемент (и удаляет его из очереди).
#  Итерируемый объект включает в себя (помимо последовательности) итератор (для циклической обработки).  Итераторы —
# это специальные объекты, представляющие последовательный доступ к данным из контейнера

# -------------------------------------------------
# 14. lambda functions
# Анонимные функции могут содержать лишь одно выражение, но и выполняются они быстрее. Анонимные функции создаются с
# помощью инструкции lambda. В стандартной библиотеке полно функций, которые принимают другие функции: map, reduce,
# filter, sorted, any, all


# -------------------------------------------------
# 15. магические методы
# контекстный менеджер (enter, exit), классы(new, init, del, getattr, setattr, str)

# -------------------------------------------------
# -------------------------------------------------
# -------------------------------------------------

# -------------------------------------------------
# 16. Как передаются аргументы в функцию

def function1(*args, **kwargs):
    pass

a = 5
b = [1, 2, 3, 4, 5]
function1(2, a, b, {'a': 1, 'b': 2}, m=(4, 4, 5))

# -------------------------------------------------
# 17. Что делает этот метод? id(object)
b = a = 2
print(id(a) == id(2))
a = a + 1
print(id(a) == id(b))
a = a + 1.5

# ------------------------------------------------
# 18. Что напечатает
import datetime as dt


def foo(time=dt.datetime.now()):
    print(time)


foo()
foo()
foo()


# ------------------------------------------------
# 19. Что напечатает
def foo(x, a=[]):
    a.append(x)
    print(a)


foo(2)
foo(3, [1, 2])
foo(4)

# -----------------------------------------------
# 20. Какой результат выполнения
print(1 == True == 2)


# -----------------------------------------------
# 21. Что напечатается
def f(*args, **kwargs):
    print(args, kwargs)


f(*[1, 2, 3])


# -----------------------------------------------
# 22. Есть ли ошибка
def is_none(arg):
    if arg:
        return False
    return True


# ------------------------------------------------
# 23. Какой результат выполнения
a = dict(one=1, two=2, three=3)
keys = a.keys()
a['four'] = 4
print(keys)

# ------------------------------------------------
# 24. В чем разница в выполнении
d = dict(zip(range(50000000), range(50000000)))
keys1 = list(d)
keys2 = d.keys()
print(49999999 in keys1)
print(49999999 in keys2)
key3 = d


# -------------------------------------------------
# 25. Для чего нужны global and nonlocal statements?


# -------------------------------------------------
# 26. Для чего нужны декораторы @staticmethod и @classmethod, что они делают.
# декораторы - это функции обертки, которые дают воможность изменить поведение функции не меняя её код.
class A:
    def b(self):
        return True


a = A()
A.b()
a.b()


# (cls, ...)
# (self, ...)

@classmethod
def f(cls):
    a.f()


# -------------------------------------------------------------
# 27. Для чего используется декоратор @functools.wraps
# Для копирования  module, name, qualname, annotations docupdates the wrapper function’s dict, что бы эти параметры
# скопировать из функции в декорирующую алиас functools.update_wrapper()

# -------------------------------------------------------------
# 28. Как в Python определить абстрактный метод?
from abc import ABC


class C(metaclass=ABC):
    pass


# --------------------------------------------------------------
# 29. Как в Python определить private атрибут или метод. Можно ли вызвать этот метод снаружи класса?


# --------------------------------------------------------------
# 30. Как добавить bound метод в класс после его объявления, как добавить bound метод в инстанс класса.
# 1) использовать types.MethodType
import types

a.foo = types.MethodType(foo, a)
a.foo

# --------------------------------------------------------------
# 31. Как получить у класса список атрибутов, методов
# Все данные объекта хранятся в «__dict__»
class Record():
    pass

record = Record()
record.id = 10
record.link = "record/"

# --------------------------------------------------------------
# 32. Для чего используется str и repr и какая между ними разница
str(g)
eval()

# --------------------------------------------------------------
# 33. Что делает оператор "with". context managers
# Менеджер контекста представляет собой объект, который создает контекст выполнения внутри оператора with и обладает
# двумя методами _enter_ и _exit_. Менеджеры контекста позволяют выделять и освобождать ресурсы строго по
# необходимости. Предположим, у вас есть две связанные операции, которые вы хотите исполнить в паре, поместив между ними
#  блок кода. Менеджеры контекста позволяют сделать именно это

# --------------------------------------------------------------
# 34. Что такое generator в Python? Как его создать?

# --------------------------------------------------------------
# 35. Что такое метаклассы в Python?

# --------------------------------------------------------------
# 36. Что делает функция type()
# type(name, bases, dict) - Возвращает новый экземпляр класса name.

# --------------------------------------------------------------
# 37. Чем отличаются методы получения типа класса isinstance(obj) type(obj) и obj.__class__

# --------------------------------------------------------------
# 38. Что такое weakref
# __weakref__ - это просто непрозрачный объект, который ссылается на все слабые ссылки на текущий объект.
# Это всего лишь деталь реализации, которая позволяет сборщику мусора информировать слабые ссылки о том, что это
# референт был собран, и больше не допускать доступ к его основному указателю.

# --------------------------------------------------------------
# 39. Чем отличаются copy.copy(x) и copy.deepcopy(x)

# --------------------------------------------------------------
# 40. Для чего используется object.__slots__
# Поведение по умолчанию можно изменить, задав __slots__ при определении класса. В __slots__ могут быть перечислены
# атрибуты для значений которых требуется зарезервировать место (с точки зрения CPython в объекте класса резервируется
# место для массива указателей на Python-объекты)

# --------------------------------------------------------------
# 41. Module.__all__ для чего используется

# --------------------------------------------------------------
# 42. плюсы и минусы множественного наследования (зло)
# при правильном использовании можно очень гибко строить код, я использовал паттер миксин в наследовании и меня вполне
# это устраивало, минус в том , что такой тип наследования позволяет скрестить абсолютно несовместимые сущности,
# что приводит к багам. Также важно понимать MRO


# --------------------------------------------------------------
# 43. MRO (method resolution order)
# слева-направо, сверху-вниз

# --------------------------------------------------------------
# 44. async, await появились в версии 3.5

# --------------------------------------------------------------
# 45. new-style и old-style классы
# Начиная с Python 2.2, помимо классических классов существует классы так называемого нового стиля. Классом нового стиля
#  называется класс, у которого базовым классом является встроенный объект (например, list или dict) или объект object.
# Для классов старого и нового стили отличаются результатом выполнения функции type(), а также вывод
# атрибутов __class__ и __bases__ для экземпляров классов.


# --------------------------------------------------------------
# 46. дескриптор-протокол
# Если объект определяет сразу и __get__, и __set__, то он считается дескриптором данных (англ. data descriptor).
# Дескрипторы, которые определили только __get__ называются дескрипторами не данных (англ. non-data descriptors).
# Их называются так, потому что они используют для методов, но другие способы их применения также возможны.
